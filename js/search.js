// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Build the Microsite",
      "url": "/sbt-microsites/docs/build-the-microsite/",
      "content": "Build the microsite Once you have written your documents, you can build the microsite running this sbt task: sbt&gt; makeMicrosite Internally, it’ll sequentially run other tasks including its own, mdoc, and makeSite (sbt-site) tasks. Multiversion support Starting on version 1.0.0 you can build microsites including different versions of your library. This is available for the light theme, and you need to have git installed and available in your system. Most probably you already have it, but in other case please check your system docs, or go to the git website on how to proceed. The feature is based on the concept of git tags. If you have different tags on your library repository, and they include sbt-microsites as part of their builds, specify the versions you want to serve in a list with their tag names, through the setting micrositeVersionList: micrositeVersionList := List(\"0.1.0\", \"0.2.0\") Then, run the following task: sbt&gt; makeMultiversionMicrosite And your home, homeFeatures, and page layouts will include a selector pointing to those version specific microsites main sites on their top navbars. View the microsite in your browser If you’re running the microsite locally, you can follow these steps: In a shell, navigate to the generated site directory in target/site. Start Jekyll with jekyll serve. Bear in mind that depending on your micrositeBaseUrl setting, you might need to serve the site setting the base url. Execute Jekyll appending that value jekyll serve -b /yourbase_url Navigate to http://localhost:4000/ or http://localhost:4000/yourbase_url/ in your browser, where yourbase_url depends on your own preferences (see micrositeBaseUrl setting). Note, if you haven’t specified any micrositeBaseUrl setting, it’ll be empty by default. Publish the microsite From version 0.5.4, you have two options to publish the site: sbt-ghpages: This is the default method. It uses the sbt-git plugin and the local ssh keys for pushing the changes. github4s: Avoids using local ssh keys, publishing the site through the GitHub HTTP API and Github4s. By contrast, you need to specify a token. Before publishing, a couple of requirements should be satisfied: Initialize the gh-pages branch, you can follow the instructions defined in the sbt-ghpages repository. Define micrositeGithubOwner and micrositeGithubRepo settings (if they can’t be infered from git remotes) and maybe the micrositePushSiteWith and micrositeGithubRepo settings. You can see more details regarding this in the Configuring the Microsite section. Once both requirements are satisfied, you can just run: sbt&gt; publishMicrosite or sbt&gt; publishMultiversionMicrosite And that’s all. Behind the scenes, makeMicrosite or makeMultiversionMicrosite, and pushSite are invoked. By default, the second task uses the sbt-ghpages plugin. If you don’t have any domain names pointing to your site, you can see your microsite at: https://username.github.io/your-microsite Enjoy!"
    } ,    
    {
      "title": "Customize",
      "url": "/sbt-microsites/docs/customize/",
      "content": "Customize The sbt-microsites plugin brings in different resources related to styles, images, and colors. But it provides a considerable scope for improvement and customization in terms of images and styles. Images As you can see in the Configuring the Microsite section, everything that you put in the directory associated with the micrositeImgDirectory setting (src/main/resources/microsite/img by default) will be copied to the generated microsite. Therefore, you can add new images in that directory, which you would reference from your markdown documents, or, you could override the default images. If you create your own images (which makes sense) and override the default ones, you can do it with these names and properties, placing them in your image directory: Light style: Microsite logo for the home page: light-navbar-brand.svg -&gt; [36x36] Microsite logo for the documentation page: light-sidebar-brand.svg -&gt; [36x36] Microsite logo for the masthead in the Features layout: features-header.svg -&gt; [500x330] Icons used by the features meta tag that we saw in the Layouts section. These features and their icons will be shown in features section in the homeFeatures page. First feature icon: first-feature-icon.svg -&gt; [56x56] Second feature icon: second-feature-icon.svg -&gt; [56x56] Third feature icon: third-feature-icon.svg -&gt; [56x56] Pattern style: Microsite logos in two different sizes for the home page: navbar_brand.png -&gt; [44x44] navbar_brand2x.png -&gt; [88x88] Microsite logos in two different sizes for the documentation page: sidebar_brand.png -&gt; [36x36] sidebar_brand2x.png -&gt; [72x72] Background pattern image for home’s Jumbotron. Jumbotron is a Bootstrap component. You can read more about it here. jumbotron_pattern.png -&gt; In this case, there isn’t a size requirement for this image. The pattern is repeated according to the screen size. Icons used by the technologies meta tag that we saw in the Layouts section. These technologies and their icons will be shown in the sub-footer in the home page. First icon: first_icon.png -&gt; [40x40] first_icon2x.png -&gt; [80x80] Second icon: second_icon.png -&gt; [40x40] second_icon2x.png -&gt; [80x80] Third icon: third_icon.png -&gt; [40x40] third_icon2x.png -&gt; [80x80] Optionally, you might want to specify your favicon.png image. Styles sbt-microsites pattern style is completely based on Bootstrap, adding some extra styles that make the microsites look great. That being said, you can personalize your microsite even further by using your own CSS files. In the same manner as we’ve just seen for images, all the css files that you place in the directory associated with the micrositeCssDirectory setting (src/main/resources/microsite/css by default) will be copied to the generated microsite. Therefore, you can add new styles, or even override existing ones. You can even use Sass/SCSS directly. For that, following Jekyll Sass/SCSS support, set all your partials in your sass directory, which will be the one specified through the micrositeSassDirectory setting (src/main/resources/microsite/sass by default). Then, place your main SCSS files in the micrositeCssDirectory (src/main/resources/microsite/css by default). These main SCSS files need to include a dummy Front Matter section on them for Jekyll to read them properly (basically, any text enclosed by --- will be valid). The files, CSS, or SCSS, will be processed and included in the layouts automatically. Colors Colors can be customized through the micrositePalette setting (take a look at the Configuring the Microsite section for a deeper explanation). Syntax Highlighting As we mentioned in the Configuring the Microsite section, micrositeHighlightTheme sbt setting allows you to specify the theme you want to use to highlight your code. It’s important to mention that the theme name should match with the one located at https://cdnjs.com/libraries/highlight.js/. https://highlightjs.org/static/demo/ provides the ability to preview the different themes before setting up your microsite. Permalinks and GitHub integration Users may want to navigate through your site docs, but they can also just use GitHub to do so. In order to achieve linkable documents that work in both Jekyll and GitHub, follow a few simple steps: Follow a directory structure where each section corresponds with a folder and a README.md file inside. README.md /content/README.md /content/whatever/README.md This will make GitHub render README.MD files as if they were the index on each section when accesing them trough the GitHub website. Add a permalink directive on each of your README.md files so that Jekyll understands that you want those to be served at the path of each folder. For example: /content/whatever/README.md --- layout: docs title: Whatever permalink: /docs/whatever/ --- Link to content normally by using Markdown relative links that point to the folder. [Link to Whatever Content](/content/whatever)"
    } ,    
    {
      "title": "Getting Started",
      "url": "/sbt-microsites/docs/getting-started/",
      "content": "Prerequisites sbt 1.3.4+ jekyll 4.0.0+ Here are a few hints for local and travis environments to satisfy the jekyll requirement. Local Environment Depending on your platform, you might do this with: yum install jekyll apt-get install jekyll gem install jekyll Note: On MacOS X, /usr/bin/gem could install an incompatible version of jekyll. It is suggested that you use Homebrew to install ruby (which provides gem) before running gem install jekyll. You can also manage your Ruby installation through rvm. Continuous Integration - Travis If you have Travis enabled for your project, you can install the gem in the Travis install section: install: - rvm use 2.6.5 --install --fuzzy - gem install jekyll -v 4 Set it up in your Project To begin, add the following lines to the project/plugins.sbt file within your project or the sbt module where you want to use the sbt-microsites plugin. Depending on the version, you might want to use: Latest release: addSbtPlugin(\"com.47deg\" % \"sbt-microsites\" % \"1.3.2\") Finally, to enable the plugin, add this to your build.sbt file: enablePlugins(MicrositesPlugin) Write your documentation .md files Your docs can be placed wherever you want in your project since there are sbt settings to point to the sources of your microsite, however the plugin expects to find the sources where mdoc have defined by default (docs/)."
    } ,      
    {
      "title": "Intro",
      "url": "/sbt-microsites/docs/",
      "content": "sbt-microsites sbt-microsites is an SBT plugin that facilitates the creation of fancy microsites for your projects, with minimal tweaks. What is a microsite? A microsite is an instance of Jekyll that’s ready to publish a static web page for your new library. Some of the benefits of having these auto-generated web pages are: You can write documentation easily in markdown format. Templates, layouts, styles and other resources will be available through the plugin at compile time. You don’t have to deal with the styling. Credits This plugin is based on and utilizes other awesome sbt plugins to make it possible. It integrates everything in a few basic steps to automatically create and publish the microsite to GitHub Pages. The plugin provides basic free styles, css, and image resources by default. Everything is based on the Bootstrap framework. If you want to personalize the color palette, styles, and images for your project, you can easily do so by viewing the steps in the documentation. Document search is provided by the Lunr.js project for client-side search functionality. In order to create microsites, this plugin directly uses the following plugins and libraries: sbt-mdoc sbt-site sbt-ghpages scalatags Additionally, it depends on other useful libraries and plugins like: sbt-scalafmt sbt-pgp sbt-header GitHub4s"
    } ,    
    {
      "title": "Layouts",
      "url": "/sbt-microsites/docs/layouts/",
      "content": "Layouts Currently, the sbt-microsites plugin includes five different layouts: There are two different options for the home section: home: The landing page–the public face of your library or project. homeFeatures: Another option for the landing page. Choosing this option, you could highlight some of the special features your library offers. (This layout is not available for the classic pattern style) docs (Optional): The page where the documentation for your library should be included. You are most likely seeing the Documentation page of this repo right now. It’s optional, depending on the micrositeDocumentationUrl setting. Take a look at the Configuring the Microsite section for an in-depth explanation. page (Optional): Similar to home, but reducing the jumbotron layer and taking into account the submenu (jumbotron and other concepts related to style are explained in the Customize section). Menu Partial: This abstract layout reads all the files in your project that fit a set of requirements, and sets up a menu under the jumbotron image. We’ll see more details on this later. Home Layout The home layout is usually related to the index.md file. In this document, you can put all the markdown content that’s related to the landing page. For instance: --- layout: home title: \"Home\" section: \"home\" technologies: - first: [\"Scala\", \"sbt-microsites plugin is completely written in Scala\"] - second: [\"SBT\", \"sbt-microsites plugin uses SBT and other sbt plugins to generate microsites easily\"] - third: [\"Jekyll\", \"Jekyll allows for the transformation of plain text into static websites and blogs.\"] --- The technology list is optional. These three technologies will be shown as a sub-footer in your home page. These technologies are identified for the set of keys (first, second, third). You can specify to include all of them or none of them. There are no other choices at this time. This list is only available in the pattern theme, but, for the light theme, we have included the homeFeatures layout where you can highlight similar characteristics of your library. HomeFeatures Layout Like the home layout, homeFeatures is related to the index.md file. This layout is designed to show a main title beside a big logo, and then a series of features that can be highlighted from the library. For instance: --- layout: homeFeatures features: - first: [\"Patterns\", \"Solutions to recurrent problems, in a purely Functional Programming manner.\", \"patterns\"] - second: [\"Typeclasses\", \"Enable ad-hoc polymorphism with protocols like Functor, Applicative, Monad, and many others.\", \"typeclasses\"] - third: [\"Data Types\", \"Take advantage of numerous data types based on algebraic properties.\", \"datatypes\"] --- This is basically all you´ll need to add to your index.md file using the homeFeatures layout. You can add up to three different features, and sbt-microsites will dispose them after the masthead layer. Every feature will be accompained by an icon that can be overridden, as explained in the Customize section. These features are identified for the set of keys (first, second, third). The last value of each feature is optional and will be used to set the link to the docs section. For instance, the first feature in the example: patterns, this will serve to compose docs/patterns link to the docs section. Docs Layout All the markdown files that contain this layout and section as docs will be grouped in the Documentation page. Each markdown file with these characteristics will be shown on a collapsible left menu, with one item per existing file. From this menu, you can easily navigate all the docs. To be able to access the documentation, you have to configure micrositeDocumentationUrl setting. In order to change the default label description for the micrositeDocumentationUrl (the default value is Documentation), you have to change the micrositeDocumentationLabelDescription. As an example, you can look at the sbt-microsites documentation at GitHub. We have several documentation files: build-the-microsite.md customize.md getting-started.md index.md … All these files contain as a header, something similar to this: --- layout: docs title: &lt;Document Title&gt; --- &lt;Document Title&gt; will be used as a menu item name on the left. How to setup the Docs Menu Looking at the Configuring the Microsite section, in the directory configured under the micrositeDataDirectory setting, you need to create a new file named menu.yml. This YAML file will be accessed by the Docs Layout in order to create the menu. Let’s see an example: options: - title: Getting Started url: docs/index section: intro - title: Configuring the Microsite url: docs/settings - title: Layouts url: docs/layouts section: resources - title: Customize url: docs/customize - title: Build the microsite url: docs/build-the-microsite The options key is mandatory. It’ll be the parent of all the options defined here. Each option or menu item will contain: title: the menu title. It should be the same as defined in the meta-property associated with the file (&lt;Document Title&gt;, where the layout is defined). url: relative path to the site URL. menu_section: this key is mandatory only when you have a nested submenu. It’ll be useful to distinguish between sub-items with the same name in different menu options. menu_type: optional parameter. It brings the ability to configure different menus for different sets of documents, defining all the menu options in the same menu.yml file. For example, you might want to define two different places in your microsite where the menu might be different. This is the setting you can use in order to group the set of menu options. Optionally, we could define a second level of nested sub-items, thanks to the nested_options key, defined at the same level that title and url of the parent menu. For example: options: - title: Introduction url: index menu_section: intro nested_options: - title: Submenu 1 url: subfolder/submenu1 - title: Submenu 2 url: subfolder/submenu2 - title: Configuring the Microsite url: settings In this example, Submenu 1 and Submenu 2 will be nested under the Introduction menu option. At the same time, submenu1 and submenu2 would have the same section name as the parent. For instance, submenu1.md would have a header like this, where the section field matches the one defined in menu.yml: --- layout: docs title: \"Submenu 2\" section: \"intro\" --- Page Layout and Menu Partial Layout This layout is useful when we want to have different web pages at the same home level, but under the menu of the microsite. One example: --- layout: page title: \"&lt;page-menu-title&gt;\" section: \"&lt;page_menu_title&gt;\" position: 3 --- For each different section the framework finds in your source directory, it’ll create a new menu option in the microsite. Let’s review this in this example: file1.md contents: --- layout: home title: \"Home\" section: \"section_home\" position: 1 --- file2.md contents: --- layout: page title: \"Section 2\" section: \"section2\" position: 3 --- file3.md contents: --- layout: page title: \"Section 3\" section: \"section3\" position: 2 --- In this case, thanks to Jekyll and the MenuPartial Layout implemented as a part of the sbt-microsites plugin, it will automatically generate a menu with three items: Home | Section 3 | Section 2 As you can see, the menu is ordered by the tag position."
    } ,      
    {
      "title": "Publish with Travis",
      "url": "/sbt-microsites/docs/publish-with-travis/",
      "content": "Publish with Travis In this section, we’re going to learn how to configure Travis so you can publish your microsite when you merge in master. There are two options for publishing the site. See Configuring the Microsite section for more information. Publish using sbt-ghpages When the property micrositePushSiteWith is set to GHPagesPlugin (by default), the site is pushed using the sbt-ghpages plugins. The steps for this approach are: 1- Generate an SSH key pair Run this command in your console $ ssh-keygen -t rsa -b 4096 -C \"Travis Deploy Key\" -f travis-deploy-key After that, you’ll see two new files in your folder: travis-deploy-key and travis-deploy-key.pub Note: If you are creating the keys in your project, maybe you should add these files to your .gitignore file. 2- Add key to GitHub Project Add the content of travis-deploy-key.pub in the Deploy Key section of the GitHub project’s settings page. Navigate to Settings &gt; Deploy Keys. Make sure you allow write access in order to push in this repository. 3- Encrypt your keys Travis needs the keys for publishing the microsite in gh-pages branch. It’s very important that you encrypt your keys using the travis command line. You have to install Travis: $ gem install travis Note: An important thing to remember is that you can only have one file encrypted in Travis. If you need more keys, you should use tar for joining your different keys. In our example, we are only going to use the key We have to encrypt the travis-deploy-key file, and we have to add the encrypted file to GitHub. First, we must be logged into Travis: $ travis login Secondly, encrypt the file: $ travis encrypt-file travis-deploy-key travis-deploy-key.enc You are going to see the following response: encrypting travis-deploy-key for [org]/[project] storing result as travis-deploy-key.enc Please add the following to your build script (before_install stage in your .travis.yml, for instance): openssl aes-256-cbc -K $encrypted_[your_number]_key -iv $encrypted_[your_number]_iv -in travis-deploy-key.enc -out travis-deploy-key -d Pro Tip: You can add it automatically by running with --add. Make sure to add keys.tar.enc to the git repository. Make sure not to add keys.tar to the git repository. Commit all changes to your .travis.yml. Finally, add the encrypted file to your git: $ git add travis-deploy-key.enc 4- Configure your .travis.yml Our recommendation is that you should use Bash Scripts and run the script when you merge the changes in master. This is the .travis.yml in sbt-microsite project: language: scala scala: - 2.12.10 jdk: - oraclejdk8 before_install: - if [ \"$TRAVIS_BRANCH\" = \"master\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then bash scripts/decrypt-keys.sh; fi install: - rvm use 2.6.5 --install --fuzzy - gem install jekyll -v 4 script: - sbt ++$TRAVIS_SCALA_VERSION test scripted after_success: - if [ \"$TRAVIS_BRANCH\" = \"master\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then bash scripts/publishMicrosite.sh; fi - if [ \"$TRAVIS_PULL_REQUEST\" = \"true\" ]; then echo \"Not in master branch, skipping deploy and release\"; fi You can see that, before we install, we run decrypt-keys.sh, then we install jekyll, and, finally, we are running publishMicrosite.sh. Next, you can see the decrypt-keys.sh script: #!/bin/sh openssl aes-256-cbc -K $encrypted_[your_number]_key -iv $encrypted_[your_number]_iv -in travis-deploy-key.enc -out travis-deploy-key -d; chmod 600 travis-deploy-key; cp travis-deploy-key ~/.ssh/id_rsa; The most important thing here is the openssl command. You should use the command that you receive as a response when you encrypt the file using the travis command above. In this script, we decrypt the keys and copy .ssh to the folder in order to publish it in GitHub later. Next, you can see the publishMicrosite.sh script: #!/bin/bash set -e git config --global user.email \"your_user_email\" git config --global user.name \"your_user_name\" git config --global push.default simple sbt docs/publishMicrosite In this script, we are publishing the microsite in GitHub Pages. To do this, we should add the user information for git. Publish using GitHub4s With this method, you don’t need to generate any ssh keys or encrypt any files. We’ll use the GitHub API for publishing the site. The steps are: 1- Create a token for your project You need to create a GitHub token with repo scope. You can create it in the GitHub settings page. Copy the token in a safe place. We’ll use this token through an environment variable as we’ll see shortly. 2- Configure your project build You need to set these two sbt settings: micrositePushSiteWith := GitHub4s micrositeGithubToken := getEnvVar(\"GITHUB_TOKEN\") 3- Add the environment variable in Travis The final step is to define the GITHUB_TOKEN environment variable in Travis Repository Settings. You can do it following the documentation."
    } ,      
    {
      "title": "Configuring the Microsite",
      "url": "/sbt-microsites/docs/settings/",
      "content": "Configuring the Microsite The following are the sbt settings that you can use to make adjustments to your microsite regarding deployment, configuration, and appearance. Not all of these settings are mandatory, since most of them have default values, as we’ll see briefly. Before you begin to detail the settings, the sbt-microsites plugin will use regular sbt configurations from your build.sbt file. In order to set up the microsite with minimal effort, all of the configurations are used as default values: Regular SBT Settings name: Default value for the microsite name. description: Value by default used for the microsite description. organizationName: Used as the microsite author by default. organizationHomepage: Used as the default microsite homepage. However, you can override these default settings by using the ones provided by the plugin, which we will describe in detail in the next section. Microsite SBT Settings We tried to provide all of the parameters that are potentially needed to configure any microsite. If you think that something needs adding, please let us know! We’re open to suggestions and contributions. micrositeName: The microsite name. As we mentioned previously, by default, it’s taken from the sbt setting name. Sometimes, it isn’t the default behavior, so you can override it like this: micrositeName := \"Your Awesome Library Name\" micrositeDescription: The microsite description. If you don’t configure this setting, the value is taken from the sbt setting description as we saw earlier. For instance: micrositeDescription := \"This is the description of my Awesome Library\" micrositeUrl: The URL prefix of your site. This setting is necessary if you need to show a poster image {micrositeUrl}{micrositeBaseUrl}/img/poster.png of your site on Twitter. See also Twitter Cards for more details. micrositeUrl := \"https://yourdomain.io\" micrositeBaseUrl: This setting brings the ability to set up a site base URL for your microsite. It’s empty by default. However, you might need something like this: micrositeBaseUrl := \"/yoursite\" In this case, your microsite would be placed on: https://yourdomain.io/yoursite. micrositeDocumentationUrl: You might need documentation pages in a specific section of your microsite. This setting allows you to personalize this URL to fit your needs. As the sbt-microsites plugin provides a specific layout to improve the look of your documentation, we strongly recommend having a look at the layouts section. It’s empty by default. Hence your Documentation link won’t appear in the microsite in that case. micrositeDocumentationUrl := \"/yoursite/docs\" Therefore, considering the example above, your microsite documentation would be placed on: https://yourdomain.io/yoursite/docs. Moreover, the layouts supplied by the plugin will provide a link in the upper-right area pointing to this URL (if it isn’t empty). micrositeDocumentationLabelDescription: The default label description for the micrositeDocumentationUrl link in the homepage is Documentation. You can change it through this setting. micrositeDocumentationLabelDescription := \"Documentation\" micrositeAuthor: The author of the microsite is taken from this sbt setting. However, if nothing is specified, the default value will be organizationName, but you can override it, as we can see in this example: micrositeAuthor := \"47 Degrees\" micrositeHomepage: Used for the homepage URL, similar to the way we’ve seen in other properties. This link is used in the footer-left link in the microsite. By default, the value is taken from the sbt setting homepage. micrositeHomepage := \"https://47deg.github.io/sbt-microsites/\" micrositeOrganizationHomepage: This particular setting is used for organizing the homepage URL, similar to the way we’ve seen in other properties. This link is used in the footer-left link in the microsite. By default, the value is taken from the sbt setting organizationHomepage. If you don´t provide any value for that setting, it will take it from the sbt setting homepage: micrositeOrganizationHomepage := \"https://www.47deg.com\" micrositeTwitter: This setting is used for the Twitter integration. This generates a meta that Twitter uses in its Twitter Cards. micrositeTwitter := \"@sbt-microsites\" micrositeTwitterCreator: This particular setting is used for the Twitter integration. This generates a meta that Twitter uses in its Twitter Cards. micrositeTwitterCreator := \"@47deg\" micrositeGithubOwner and micrositeGithubRepo: Used to add links to the GitHub repo. It’s also needed for publishing the site when github4s is chosen (see micrositePushSiteWith setting). Defaults to the information found in the ‘origin’ Git remote, if such remote exists; otherwise they must be set like: micrositeGithubOwner := \"47deg\" micrositeGithubRepo := \"sbt-microsites\" micrositeGithubToken: Used for publishing the site when github4s is enabled. A token with repo scope is needed. None by default, but you can override it in this way: micrositeGithubToken := getEnvVar(\"GITHUB_TOKEN\") micrositePushSiteWith: Determines how the site will be pushed. It accepts two values: GHPagesPlugin: The default value. The plugin will use the sbt-ghpages plugin for publishing the site. GitHub4s: The GitHub4s will be used for publishing the site. By now, only GitHub is supported. You need to specify a value for the micrositeGithubToken in order to use this publishing method. micrositePushSiteWith := GitHub4s micrositeGitHostingService and micrositeGitHostingUrl: Used to specify a hosting service other than GitHub. If you are using a privately hosted GitHub instance, you can set the micrositeGitHostingUrl to override the default github.com and repo name configuration. micrositeGitHostingService := GitLab micrositeGitHostingUrl := \"https://gitlab.com/gitlab-org/gitlab-ce\" micrositeAnalyticsToken: Property id of Google Analytics. This is empty by default. micrositeAnalyticsToken := 'UA-XXXXX-Y' micrositeGithubLinks: This setting defines whether to show/hide GitHub links for stars and forks in docs layout. By default, it is enabled. micrositeGithubLinks := true micrositeGitterChannel: This setting is used to enabled the Gitter sidecar Channel functionality, and it’s enabled by default. The chat room is taken from micrositeGithubOwner and micrositeGithubRepo. micrositeGitterChannel := true micrositeGitterChannelUrl: This setting is used to set a custom URL to Gitter sidecar Channel. By default, this is micrositeGithubOwner/micrositeGithubRepo. micrositeGitterChannelUrl := \"47deg/sbt-microsites\" micrositeShareOnSocial: This setting defines whether to show/hide the social media buttons in docs layout. By default, it is enabled. micrositeShareOnSocial := true micrositeHighlightTheme: By default, the theme of Highlight.js is vs. However, you can configure it to a different theme thanks to this setting: micrositeHighlightTheme := \"monokai\" Available themes: https://cdnjs.com/libraries/highlight.js/ micrositeHighlightLanguages: By default, Highlight.js is configured to support syntax highlighting for java, scala, and bash. You can add additional languages: micrositeHighlightLanguages ++= Seq(\"protobuf\", \"thrift\") Then, use it as follows: ```protobuf message MyMessage { optional int32 i = 1; } ``` Available languages: https://cdnjs.com/libraries/highlight.js/ micrositeImgDirectory: The plugin provides some basic images, but you can add new images to personalize the microsite. This is the property where you can specify where they will be placed. The images in this folder will be automatically copied by the plugin, and they will be placed together with the rest of the Jekyll resources. By default, its value is (resourceDirectory in Compile).value / \"microsite\" / \"img\", but you can override it. For instance: micrositeImgDirectory := (resourceDirectory in Compile).value / \"site\" / \"images\" micrositeCssDirectory: You can also override the styles through the micrositeCssDirectory setting by using the same method. The css files in that folder will be automatically copied and imported by the plugin in your microsite. The default value is (resourceDirectory in Compile).value / \"microsite\" / \"css\", but you can override it like this: micrositeCssDirectory := (resourceDirectory in Compile).value / \"site\" / \"styles\" micrositeSassDirectory: If you want to use SCSS files, you might want to override the place to put the partials. This can be done through the micrositeSassDirectory setting. The main SCSS files need to go into the CSS directory, where they will be transformed into CSS files, and the partials will be loaded from this directory. The default value is (resourceDirectory in Compile).value / \"microsite\" / \"sass\", but you can override it like this: micrositeSassDirectory := (resourceDirectory in Compile).value / \"site\" / \"partials\" micrositeJsDirectory: You can also introduce custom javascript files in the generated microsite through the micrositeJsDirectory setting by using the same method. The javascript files in that folder will be automatically copied and imported by the plugin in your microsite. The default value is (resourceDirectory in Compile).value / \"microsite\" / \"js\", but you can override it like this: micrositeJsDirectory := (resourceDirectory in Compile).value / \"site\" / \"scripts\" There is a reserved filename that you cannot use in your personal microsite: main.js, which is provided by the plugin. micrositeCDNDirectives: This setting provides the ability to include CDN imports (for js and css files) along the different layouts in this way: micrositeCDNDirectives := CdnDirectives( jsList = List( \"https://cdnjs.cloudflare.com/ajax/libs/ag-grid/7.0.2/ag-grid.min.js\", \"https://cdnjs.cloudflare.com/ajax/libs/ajaxify/6.6.0/ajaxify.min.js\" ), cssList = List( \"https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.css\", \"https://cdnjs.cloudflare.com/ajax/libs/cssgram/0.1.12/1977.min.css\", \"https://cdnjs.cloudflare.com/ajax/libs/cssgram/0.1.12/brooklyn.css\" ) ) micrositeExternalLayoutsDirectory: You can also introduce custom html layouts in the generated microsite through the micrositeExternalLayoutsDirectory setting. The layout files in that folder will be automatically copied and imported by the plugin in your microsite. The default value is (resourceDirectory in Compile).value / \"microsite\" / \"layouts\", but you can override it like this: micrositeExternalLayoutsDirectory := (resourceDirectory in Compile).value / \"site\" / \"layouts\" These will be available to your pages by using the layout keyword in the YAML front matter block in each of your docs’ markdown files (i.e., having included a extra-layout.html external layout file): --- title: Foo Bar layout: extra-layout --- micrositeExternalIncludesDirectory: You can also introduce custom html partial layouts in the generated microsite through the micrositeExternalIncludesDirectory setting. The layout files in that folder will be automatically copied and imported by the plugin in your microsite. The default value is (resourceDirectory in Compile).value / \"microsite\" / \"includes\", but you can override it like this: micrositeExternalIncludesDirectory := (resourceDirectory in Compile).value / \"site\" / \"includes\" These will be available to your pages by using Jekyll’s include keyword in your layouts. micrositeDataDirectory: In addition, you can provide new data to your Jekyll site through the micrositeDataDirectory setting. It’s based on the idea of Jekyll Data Files. It’s important to keep in mind that, if you are defining documentation in your microsite, you have to configure the menu through this setting. The default value is (resourceDirectory in Compile).value / \"microsite\" / \"data\", but you can override it like this: micrositeDataDirectory := (resourceDirectory in Compile).value / \"site\" / \"mydatafiles\" In the Documentation Menu case, as you can see in the layouts section, you need to create a file named menu.yml under the micrositeDataDirectory setting. micrositeStaticDirectory: You can also provide a static directory to your Jekyll site through the micrositeStaticDirectory setting. It’s based on the idea of Jekyll Static Files. The default value is (resourceDirectory in Compile).value / \"microsite\" / \"static\", but you can override it like this: micrositeStaticDirectory := (resourceDirectory in Compile).value / \"site\" / \"mystaticfiles\" The directory will be copied as-is, but no process will be applied to any file on it. So the responsibility of loading/linking/using them on a layout is yours. Also, see the includeFilter in makeSite config setting for the allowed file types that will be copied. micrositeExtraMdFiles: This setting can be handy if you want to include additional markdown files in your site, and these files are not located in the same place in your mdoc directory. By default, the setting is set up as an empty map. You can override it in this way: micrositeExtraMdFiles := Map( file(\"README.md\") -&gt; ExtraMdFileConfig( \"readme.md\", \"home\" ), file(\"CONSEQUAT.md\") -&gt; ExtraMdFileConfig( \"consequat.md\", \"page\", Map(\"title\" -&gt; \"Consequat\", \"section\" -&gt; \"consequat\", \"position\" -&gt; \"5\") ) ) Each file (the map key) can be related to a specific configuration through the ExtraMdFileConfig case class. This class allows you to specify three additional configurations: The target file name. The plugin will copy the file, and it will put it in mdoc directory each time you build the microsite. Therefore, you might want to include this auto-copied file in the list of ignored files at the .gitignore file. Jekyll layout property. Other custom Jekyll properties that you might want to include in your document. A good point to highlight here is that through the permalink property you can control the place where Jekyll is going to move your extra file. The value of this property prevails over the folder where the file is copied. micrositeExtraMdFilesOutput this is an optional parameter when you are using mdoc, and refers to the microsite output location for extra-md files. Default is resourceManaged + /jekyll/extra_md although you can modify it. micrositePluginsDirectory: You can also introduce custom Jekyll plugins in the generated microsite through the micrositePluginsDirectory setting. The plugin files in that folder will be automatically copied and imported by the plugin in your microsite. The default value is (resourceDirectory in Compile).value / \"microsite\" / \"plugins\", but you can override it like this: micrositePluginsDirectory := (resourceDirectory in Compile).value / \"site\" / \"plugins\" micrositeHomeButtonTarget: Where the large “call-to-action button” on your home page should take users. By default is set to repo for your project repository. Can be set to docs to take users to the project documentation page, if configured. micrositeSearchEnabled: Whether or not the search bar functionality is enabled for your microsite. Enabled by default. To disable, set to false. micrositeTheme: You can choose two different themes to generate your microsite. By default it will display the light theme but you have the option of choosing the classic pattern theme. micrositeTheme := \"pattern\" micrositePalette: The default microsite style essentially uses three colors. You can configure all of them, as seen below. Default palette used by the light theme: micrositePalette := Map( \"brand-primary\" -&gt; \"#013567\", \"brand-secondary\" -&gt; \"#009ADA\", \"white-color\" -&gt; \"#FFFFFF\") Palette used by the pattern theme: micrositePalette := Map( \"brand-primary\" -&gt; \"#E05236\", \"brand-secondary\" -&gt; \"#3F3242\", \"brand-tertiary\" -&gt; \"#2D232F\", \"gray-dark\" -&gt; \"#453E46\", \"gray\" -&gt; \"#837F84\", \"gray-light\" -&gt; \"#E3E2E3\", \"gray-lighter\" -&gt; \"#F4F3F4\", \"white-color\" -&gt; \"#FFFFFF\") micrositeFavicons: List of filenames and sizes for the PNG/ICO files to be used as favicons for the generated site, located in the default image directory. The sizes should be described with a string (i.e.: \"16x16\"). If not provided, favicons with different sizes will be generated from the navbar_brand2x.png file for the pattern style and from the light_navbar_brand.png in case we are using the light style. micrositeFavicons := Seq(MicrositeFavicon(\"favicon16x16.png\", \"16x16\"), MicrositeFavicon(\"favicon32x32.png\", \"32x32\")) micrositeConfigYaml: This setting brings the capability to customize the Jekyll _config.yml file in three different ways (not exclusive to each other): Specifying a provided _config.yml as a part of your library resources. Specifying a YAML string inline in the sbt configuration (you might want to consider the use of stripMargin). Through custom liquid variables. These three ways will be merged in order to generate the final and single _config.yml file. This is possible thanks to the ConfigYml case class, which looks like the following: case class ConfigYml( yamlCustomProperties: Map[String, Any] = Map.empty, yamlPath: Option[File] = None, yamlInline: String = \"\" ) Therefore, the next snippet represents an example that combines these three ways: micrositeConfigYaml := ConfigYml( yamlCustomProperties = Map(\"org\" -&gt; \"My Org\"), yamlInline = \"\"\"exclude: [package.json, grunt.js, Gruntfile.js, node_modules] |\"\"\".stripMargin, yamlPath = Some((resourceDirectory in Compile).value / \"microsite\" / \"myconfig.yml\") ) micrositeFooterText: This setting allows the optional configuration of the second line in the footer. By default, it is set to Some(\"\"\"Website built with \"Sbt-microsites © 2019 47 Degrees\"\"\"). This string is passed in unsanitized to the templating engine.. If this setting is set to None, the second line is not displayed. micrositeFooterText := Some(\"&lt;b&gt;Bob&lt;/b&gt; the &lt;i&gt;Builder&lt;/i&gt;\") micrositeEditButtonText: This setting allows the optional inclusion and configuration of an edit button on pages with the docs layout. The button links to the given path of the page in its repository. By default, it is set to None and not visible. To enable, set the MicrositeEditButton with text for the button and the basePath for the file. The basePath is comprised of the file URL excluding the top-level repository URL, and should include the dynamic property {% raw %}{{page.path}}{% endraw %} that will be generated for each page when Jekyll compiles the site. The strings are passed in unsanitized to the templating engine. {% raw %}micrositeEditButton := Some(MicrositeEditButton(\"Improve this Page\", \"/edit/master/docs/{{ page.path }}\")){% endraw %} includeFilter in makeSite: Restrict the type of files that are included during the microsite build. The default value is \"*.html\" | \"*.css\" | \"*.png\" | \"*.jpg\" | \"*.jpeg\" | \"*.gif\" | \"*.js\" | \"*.swf\" | \"*.md\" | \"*.webm\" | \"*.ico\" | \"CNAME\" | \"*.yml\" | \"*.svg\" | \"*.json\" but you can override it like this: includeFilter in makeSite := \"*.csv\" | \"*.pdf\" | *.html\" | \"*.css\" | \"*.png\" | \"*.jpg\" | \"*.jpeg\" | \"*.gif\" | \"*.js\" | \"*.swf\" | \"*.md\" | \"*.webm\" | \"*.ico\" | \"CNAME\" | \"*.yml\" | \"*.svg\" | \"*.json\""
    } ,    
    {
      "title": "Troubleshooting",
      "url": "/sbt-microsites/docs/troubleshooting/",
      "content": "Troubleshooting Site has no styling Problem: After upgrading from sbt-microsites 0.x to 1.x, my microsite has no styling at all. The target/site/css/ directory is not being generated. Solution: You probably have the wrong version of Jekyll installed. sbt-microsites 0.x had a dependency on Jekyll 3.x, but sbt-microsites 1.x requires Jekyll 4.0.0 or newer."
    } ,    
    {
      "title": "Typechecked Snippets",
      "url": "/sbt-microsites/docs/typechecked-snippets/",
      "content": "Typechecked Snippets As has been mentioned a couple of times throughout this tutorial, this plugin supports the compilation of Scala code written in markdown files. This process is now being delegated on mdoc. mdoc mdoc is the option by default, so no special action is required from your side. See the scalameta site for more information here. Here is some advice for using this in your microsite: Add your markdown files in this path by default: docs/. If you want to place your documents in a different path, just set the sbt property mdocIn := your-path being your-path a SettingKey[File]. Mark the snippets that you want to compile, following this convention: ```scala mdoc or any of its modifiers Migrating from tut to mdoc If your project is still based on tut, you can migrate it from tut to mdoc can follow this migration guide. There is also a script that does the replacement for you."
    }    
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
